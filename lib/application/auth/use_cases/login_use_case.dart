import 'package:recetasperuanas/domain/auth/entities/user.dart';
import 'package:recetasperuanas/domain/auth/repositories/i_user_auth_repository.dart';
import 'package:recetasperuanas/domain/auth/value_objects/email.dart';
import 'package:recetasperuanas/domain/core/value_objects.dart';

/// Use case for user login
class LoginUseCase {
  const LoginUseCase(this._authRepository);

  final IUserAuthRepository _authRepository;

  /// Execute login with email and password
  Future<Result<User, DomainException>> execute({
    required String email,
    required String password,
  }) async {
    // Validate email
    final emailResult = Email.create(email);
    if (emailResult.isFailure) {
      return Failure(emailResult.failureValue!);
    }

    // Validate password
    if (password.isEmpty) {
      return const Failure(
        ValidationException('La contraseña no puede estar vacía'),
      );
    }

    // Authenticate user
    return await _authRepository.authenticate(
      emailResult.successValue!,
      password,
    );
  }

  /// Execute Google login
  Future<Result<User, DomainException>> executeWithGoogle() async {
    return await _authRepository.authenticateWithGoogle();
  }
}

/// Use case for user registration
class RegisterUseCase {
  const RegisterUseCase(this._authRepository);

  final IUserAuthRepository _authRepository;

  /// Execute user registration
  Future<Result<User, DomainException>> execute({
    required String email,
    required String password,
    String? name,
    String? photoUrl,
  }) async {
    // Create user entity with validation
    final userResult = User.create(
      id: '', // Will be generated by repository
      email: email,
      password: password,
      name: name,
      photoUrl: photoUrl,
    );

    if (userResult.isFailure) {
      return Failure(userResult.failureValue!);
    }

    // Register user
    return await _authRepository.register(userResult.successValue!);
  }
}

/// Use case for user logout
class LogoutUseCase {
  const LogoutUseCase(this._authRepository);

  final IUserAuthRepository _authRepository;

  /// Execute user logout
  Future<Result<void, DomainException>> execute() async {
    return await _authRepository.signOut();
  }
}

/// Use case for getting current user
class GetCurrentUserUseCase {
  const GetCurrentUserUseCase(this._authRepository);

  final IUserAuthRepository _authRepository;

  /// Execute get current user
  Future<Result<User?, DomainException>> execute() async {
    return await _authRepository.getCurrentUser();
  }
}
