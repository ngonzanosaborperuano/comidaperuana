---
alwaysApply: true
---
## üîÑ Proceso de Actualizaci√≥n

Cuando implementes algo NUEVO:

### Durante la Implementaci√≥n
1. **Usar componentes existentes** identificados en la documentaci√≥n
2. **Seguir patrones establecidos** documentados
3. **No duplicar funcionalidad** que ya existe

### Despu√©s de la Implementaci√≥n
1. **Actualizar el archivo .md correspondiente** con el nuevo componente
2. **Actualizar `docs/README.md`** si es necesario
3. **Considerar si se necesitan nuevas utilidades/constantes**

---

## üö® Ejemplos de Aplicaci√≥n
### ‚ùå INCORRECTO (No consultar docs):
```dart
// Crear BLoC sin verificar patrones existentes
class UserBloc extends Bloc<UserEvent, UserState> {
  // ‚ùå No seguir Clean Architecture documentada
  // ‚ùå No usar fpdart para errores
}

// Usar colores hardcodeados sin verificar AppTheme
Container(
  color: Colors.black, // ¬°Ya est√° en AppTheme!
  child: Text(
    'Hello',
    style: TextStyle(color: Colors.white), // ¬°Usar textTheme!
  ),
)

// Crear widgets sin verificar shared/widgets/
class CustomButton extends StatelessWidget {
  // ¬°Puede que ya exista un ButtonWidget similar!
}
```

### ‚úÖ CORRECTO (Consultar docs primero):
```dart
// 1. Leer docs/README.md y bloc_data_flow.md
// 2. Ver patrones establecidos de BLoC con fpdart
// 3. Implementar siguiendo el patr√≥n:
class UserBloc extends Bloc<UserEvent, UserState> {
  final GetUserUseCase getUserUseCase;
  
  UserBloc({required this.getUserUseCase}) : super(const UserState.initial()) {
    on<GetUserEvent>(_onGetUser);
  }
  
  Future<void> _onGetUser(GetUserEvent event, Emitter<UserState> emit) async {
    emit(const UserState.loading());
    
    final result = await getUserUseCase(event.userId);
    
    result.fold(
      (failure) {
        logger.e('Failed to get user', error: failure);
        emit(UserState.error(failure));
      },
      (user) {
        logger.i('User loaded successfully');
        emit(UserState.loaded(user));
      },
    );
  }
}

// 1. Consultar docs/README.md sobre theme system
// 2. Ver que AppTheme debe usarse siempre
// 3. Usar theme correctamente:
Container(
  color: Theme.of(context).colorScheme.surface,
  child: Text(
    'Hello',
    style: Theme.of(context).textTheme.bodyLarge,
  ),
)

// 1. Revisar shared/widgets/ antes de crear
// 2. Si no existe, crear siguiendo patrones
// 3. Documentar en docs/README.md despu√©s
```

---

## üìã Checklist Obligatorio

Antes de escribir c√≥digo, confirmar:

- [ ] **He le√≠do `docs/README.md`**
- [ ] **He consultado el archivo .md relevante**
- [ ] **He verificado que no estoy duplicando funcionalidad**
- [ ] **Estoy usando componentes/utilidades existentes**
- [ ] **Seguir√© los patrones documentados**

Despu√©s de escribir c√≥digo:

- [ ] **He actualizado la documentaci√≥n correspondiente**
- [ ] **He verificado que sigo las reglas de flutter_code_basics**

---

## üéØ Beneficios de Seguir Esta Regla

1. **Evitar duplicaci√≥n** de c√≥digo y esfuerzo
2. **Mantener consistencia** arquitectural
3. **Reutilizar validaciones** y utilidades robustas
4. **Acelerar desarrollo** usando componentes existentes
5. **Facilitar mantenimiento** con documentaci√≥n actualizada

---

## ‚ö†Ô∏è Consecuencias de NO Seguir

- C√≥digo duplicado dif√≠cil de mantener
- Inconsistencias en validaciones y formatos
- P√©rdida de tiempo recreando funcionalidad existente
- Bugs por no usar utilidades probadas
- Documentaci√≥n desactualizada

---

## @todo

- Revisar y actualizar esta regla cuando se agreguen nuevas categor√≠as de componentes
- Considerar automatizaci√≥n de verificaci√≥n de duplicaci√≥n
- Evaluar agregar templates de documentaci√≥n para nuevos componentes

---

**√öltima actualizaci√≥n:** Creaci√≥n de sistema de documentaci√≥n t√©cnica en Paso 2
description:
globs:
alwaysApply: false
---
